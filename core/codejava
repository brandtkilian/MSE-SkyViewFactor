    // heliostat project : calcul et conception avec les reflets du soleil
    // by concept.pg
    // copyright : peter gallinelli (c) 2016 tous droits reserves

    // déclarations préalables
    double[] tableSrc = {19, 20, 21, 23, 27, 27, 28, 28, 28}; // table de calibrage (toutes les 10 deg // Kodak SP360)
    double imgViewAngle = 180; // angle de vue de la photo (fish-eye = 180, Kodak SP360 = 235) [deg]
    float scaleFactor = 1.2f; // brightness
    float scaleOffset = 0; // brightness offset

    /**
     * Image deformation effects
     * image Image : image to transform
     * @return corImage
     * methode : (c) peter gallinelli
     */
    private Image imageCorrections(Image image) {
        // transfer image data into bufferedImage and create correctedImage
        BufferedImage srcImage =
            new BufferedImage(image.getWidth(null), image.getHeight(null), BufferedImage.TYPE_INT_RGB);
        srcImage.getGraphics().drawImage(image, 0, 0, null);
        BufferedImage corImage =
            new BufferedImage(image.getWidth(null), image.getHeight(null), BufferedImage.TYPE_INT_RGB);

        // centre de l'image
        double xCenter = srcImage.getWidth() * 0.5;
        double yCenter = srcImage.getHeight() * 0.5;

        // table intervalles corriges (reguliers)
        double rI = srcImage.getWidth() / 2;
        double[] tableCor = {rI / 9, rI / 9, rI / 9, rI / 9, rI / 9, rI / 9, rI / 9, rI / 9, rI / 9}; // rG : 315 / 9 = 35
        double distSmax = 0; // rayon utile du fisheye [px]
        for (int i = 0; i < tableSrc.length; i++)
            distSmax = distSmax + tableSrc[i];

        // scan chaque pixel
        for (int xCor = 0; xCor < srcImage.getWidth(); xCor++) {
            for (int yCor = 0; yCor < srcImage.getHeight(); yCor++) {
                // interpolation selon fonction de deformation
                // conversion des x/y du pixel en coordonnees polaires
                double dx = xCor - xCenter;
                double dy = yCor - yCenter;
                double rCor = Math.sqrt(dx * dx + dy * dy); // distance au centre (pythagore)

                // correction si a l'interieur de la zone utile de la photo (> horizontale)
                if (rCor * rG / xCenter < rG) {
                    int xSrc = xCor;
                    int ySrc = yCor;

                    if (optics) {
                        // direction du pixel par rapport au centre
                        double alpha = Math.asin(dx / rCor);
                        // leve d'ambiguite de Math.asin
                        if (yCor > yCenter)
                            alpha = Math.PI - alpha;

                        // recherche de l'intervalle dans la table de correction
                        int i = 0;
                        double sumSrc = 0;
                        double sumCor = 0;
                        while (sumCor < rCor && i < tableSrc.length - 2) {
                            sumSrc += tableSrc[i] * rI / rG; // applique correction pour taille d'image
                            sumCor += tableCor[i];
                            i++;
                        }
                        // calcul du rayon corrige
                        double rSrc = sumSrc + (tableSrc[i] * rI / rG) * (rCor - sumCor) / tableCor[i];

                        // conversion de coordonnees polaire en x/y
                        xSrc = (int)(xCenter + rSrc * Math.sin(alpha));
                        ySrc = (int)(yCenter - rSrc * Math.cos(alpha));
                    }

                    // get pixel RGB value from the distorted image
                    xSrc = Math.max(0, Math.min(xSrc, srcImage.getWidth() - 1));
                    ySrc = Math.max(0, Math.min(ySrc, srcImage.getHeight() - 1));

                    // correction luminosite
                    Color srcCol = new Color(srcImage.getRGB(xSrc, ySrc));
                    int pxR = Math.min((int)(srcCol.getRed() * scaleFactor + scaleOffset), 255);
                    int pxG = Math.min((int)(srcCol.getGreen() * scaleFactor + scaleOffset), 255);
                    int pxB = Math.min((int)(srcCol.getBlue() * scaleFactor + scaleOffset), 255);
                    Color corCol = new Color(pxR, pxG, pxB);

                    // set pixel RGB in destination image
                    corImage.setRGB(xCor, yCor, corCol.getRGB());
                } else {
                    if (printCol) {
                        Color myWhite = new Color(255, 255, 255);
                        int rgb = myWhite.getRGB();
                        corImage.setRGB(xCor, yCor, rgb); // set pixel to white
                    } else
                        corImage.setRGB(xCor, yCor, 0); // else set pixel to black
                }
            }
        }
        return corImage;
    }




    dx = xCor - xCenter
                dy = yCor - yCenter
                rCor = math.sqrt(dx * dx + dy * dy)
                if rCor * rG / xCenter < rG:
                    xSrc = xCor
                    ySrc = yCor

                    if dx != 0 or dy != 0:
                        alpha = math.asin(dx / rCor)
                        if yCor > yCenter:
                            alpha = math.pi - alpha

                        i = 0
                        sumSrc = 0
                        sumCor = 0
                        while sumCor < rCor and i < len(self.tableSrc) - 2:
                            sumSrc += self.tableSrc[i] * rI / rG
                            sumCor += tableCorr[i]
                            i += 1
                        rSrc = sumSrc + (self.tableSrc[i] * rI / rG) * (rCor - sumCor) / tableCorr[i]
                        xSrc = int(xCenter + rSrc * math.sin(alpha))
                        ySrc = int(yCenter - rSrc * math.cos(alpha))

                    xSrc = max(0, min(xSrc, width - 1))
                    ySrc = max(0, min(ySrc, height - 1))